# 5.如何驯服斜放的雷达

这是一个在机器人和自动驾驶领域中常见且重要的问题。当激光雷达(LiDAR)相对于惯性测量单元(IMU)或车体坐标系存在倾斜安装时，如果不能正确地配置其外参，将会严重影响SLAM算法的建图和定位精度。

## 从雷达的外参说起

在大多数SLAM框架（如`FAST-LIO`）的配置文件中，我们都能找到用于描述LiDAR和IMU之间相对位姿的参数。这通常被称为外参（Extrinsics）。

以`FAST-LIO`为例，其配置文件`config/mid360.yaml`中包含以下参数：
```yaml
# LiDAR到IMU的外参
extrinsic_T: [ -0.011, -0.02329, 0.04412 ]
extrinsic_R: [ 1., 0., 0.,
         0., 1., 0.,
         0., 0., 1.]
```

这里的参数定义了从**LiDAR坐标系**到**IMU坐标系**的变换关系，即 $T_{imu\_lidar}$。

-   `extrinsic_T`: 表示从LiDAR坐标系原点到IMU坐标系原点的**平移向量**，单位为米。
-   `extrinsic_R`: 表示从LiDAR坐标系到IMU坐标系的**旋转矩阵**。它是一个3x3的矩阵，在YAML文件中通常以行主序的9个元素数组表示。

### 理解旋转矩阵 `extrinsic_R`

在上述示例配置中，`extrinsic_R`是一个单位矩阵。这表示**LiDAR坐标系与IMU坐标系的姿态是完全对齐的**，即X轴、Y轴、Z轴分别平行。

然而，当雷达被**倾斜**或**旋转**安装时，这个矩阵就不再是单位矩阵了。例如，如果LiDAR绕其自身的Y轴向前倾斜了15度，而imu的安装方式没变，那么从LiDAR到IMU的旋转关系就需要相应地更新。

> 值得注意的是,MID360在使用内部IMU的时候,不管你怎么倾斜放置,imu和lidar的相对位姿都是不变的(可以理解成焊死了),所以不需要改.

### 这个参数的作用

这个参数告诉了里程计要如何处理lidar和imu的数据。而在默认情况下，这个参数是**不需要进行修改的**!试想一下，你拿着雷达在空间中晃动，但是里程计却在正常的运行和定位，这个期间$T_{imu\_lidar}$其实并没有发生变化!而如果这个参数被错误地设置,你的里程计很有可能会飞出宇宙之外。

> TODO: 你可以尝试调整`livox_ros_driver2/config/MID360_config.json`中的`lidar_configs.extrinsic_parameter.pitch(yaw)`,比如调整这个参数让你的点云看起来是与地面平行的。然后在默认参数下启动你的里程计,转一下yaw,然后你就会发现里程计像醉了酒一样来回摇摆甚至直接没救的飞出去,~~飞(里程)计悲~~。这个时候你相当于调整了lidar和imu的外参,但是里程计里面的参数`extrinsic_T`和`extrinsic_R`却没有调整,于是不出意外的出意外了。

所以,即使你的雷达是倾斜安装的,不修改这个参数,你的里程计定位也不会出现问题,只是里程计的表达换了一个参考坐标系——如果你的雷达是水平放置的,你的里程计就是基于一个初始水平的坐标系表达的;如果你的雷达是倾斜放置的,你的里程计就是基于一个初始倾斜的坐标系表达的。

这显然会导致很多问题。比如以`FAST-LIO`为例,如果你的雷达倾斜30°放置,里程计表达的默认的坐标变换为`camera_init`->`body`,那么这两个坐标系也都是倾斜30°的,而最后建出来的图也是倾斜30°的,发布的点云倾斜30°的,这显然很不方便!

而为了解决这一问题,我们有几种方法。

### 方法一:调整点云的角度并调整外参(标定)

这个方法需要同时调整`livox_ros_driver2/config/MID360_config.json`中的`lidar_configs.extrinsic_parameter.pitch`,并调整里程计里面的参数`extrinsic_T`和`extrinsic_R`。

一般来说对于这种流程,我们有个更常见的名字,叫**标定**

#### 推荐工具：`LiDAR_IMU_Init`

对于LiDAR和IMU外参的自动标定，推荐使用香港大学MARS实验室开源的工具包 [**LiDAR_IMU_Init**](https://github.com/hku-mars/LiDAR_IMU_Init)。

**使用说明：**

*   **ROS 1 环境：**
  该工具是一个标准的ROS 1功能包，可以直接在ROS 1系统上编译和运行。

*   **ROS 2 环境：**
  如果您在ROS 2环境下工作，可以遵循以下流程：
  1.  使用 `ros2 bag record` 录制数据包。**注意**：请确保点云话题的格式为 `sensor_msgs/PointCloud2`,而不是`livox_ros_driver2/CustomMsg`.
  2.  将录制好的 `rosbag2` 文件转换为ROS 1兼容的 `.bag` 格式。
  3.  在ROS 1环境中使用转换后的数据包运行标定程序。

*   **Docker 环境：**
  官方也提供了Docker镜像，可以帮助用户快速搭建运行环境，避免繁琐的依赖配置。(我没测试过)

### 方法二:基于初始IMU数据作gravity\_align(更推荐)

查看Point-LIO的参数文件,可以看到一个神奇的东西:

```yaml
gravity: [0.0, 0.0, -9.810]                     # [0.0, 9.810, 0.0] # # [0.0, 0.0, -9.787561] # gvins #
gravity_init: [0.0, 0.0, -9.810]                # preknown gravity in the initial IMU frame for unstationary start or in the initial LiDAR frame for using without IMU
```

这个东西是干什么的呢?
在`IMU_Processing.cpp`中有着一段代码:

```cpp
void ImuProcess::Set_init(Eigen::Vector3d & tmp_gravity, Eigen::Matrix3d & rot)
{
  /** 1. initializing the gravity, gyro bias, acc and gyro covariance
   ** 2. normalize the acceleration measurenments to unit gravity **/
  // V3D tmp_gravity = - mean_acc / mean_acc.norm() * G_m_s2; // state_gravity;
  M3D hat_grav;
  hat_grav << 0.0, gravity_(2), -gravity_(1), -gravity_(2), 0.0, gravity_(0), gravity_(1),
    -gravity_(0), 0.0;
  double align_norm = (hat_grav * tmp_gravity).norm() / gravity_.norm() / tmp_gravity.norm();
  double align_cos = gravity_.transpose() * tmp_gravity;
  align_cos = align_cos / gravity_.norm() / tmp_gravity.norm();
  if (align_norm < 1e-6) {
    if (align_cos > 1e-6) {
      rot = Eye3d;
    } else {
      rot = -Eye3d;
    }
  } else {
    V3D align_angle = hat_grav * tmp_gravity / (hat_grav * tmp_gravity).norm() * acos(align_cos);
    rot = Exp(align_angle(0), align_angle(1), align_angle(2));
  }
}
```

这段代码的**核心目标**是计算一个旋转矩阵 `rot`。这个旋转矩阵的作用是将IMU（惯性测量单元）在初始静止时测量到的重力向量 `tmp_gravity` 旋转到与一个已知的、标准的重力向量 `gravity_` 对齐。

简单来说，IMU刚上电时，它不知道自己的姿态，但它能通过加速度计感受到重力的方向。这段代码就是利用这个感受到的重力方向，来计算出IMU的初始**俯仰（Pitch）和横滚（Roll）姿态，从而完成初始化。这个过程也被称为重力对准**。

该算法基于经典的\*\*轴-角表示法（Axis-Angle Representation）\*\*来寻找两个向量之间的旋转关系。

1.  **旋转轴**：要想将向量`A`旋转到向量`B`，旋转轴必然同时垂直于`A`和`B`。这个轴可以通过计算它们的**叉乘** `A × B` 得到。
2.  **旋转角**：旋转的角度`θ`可以通过计算两个向量的**点乘**得到，因为 `A · B = |A| |B| cos(θ)`。

代码正是实现了这个逻辑。

而在主要逻辑代码`laserMapping.cpp`中,它是这样被调用的:

```cpp
if (!p_imu->after_imu_init_) {
  if (!p_imu->imu_need_init_) {
    V3D tmp_gravity;
    if (imu_en) {
      tmp_gravity = -p_imu->mean_acc / p_imu->mean_acc.norm() * G_m_s2;
    } else {
      tmp_gravity << VEC_FROM_ARRAY(gravity_init);
      p_imu->after_imu_init_ = true;
    }
    // V3D tmp_gravity << VEC_FROM_ARRAY(gravity_init);
    M3D rot_init;
    p_imu->Set_init(tmp_gravity, rot_init);
    kf_input.x_.rot = rot_init;
    kf_output.x_.rot = rot_init;
    kf_output.x_.acc = -rot_init.transpose() * kf_output.x_.gravity;
  } else {
    continue;
  }
}
```

#### 代码调用流程分析

这段在`laserMapping.cpp`中的代码是整个重力对准逻辑的“上层应用”。它决定了**何时**以及**如何**获取用于对准的重力向量，并最终将计算出的旋转矩阵应用到系统的状态估计中。

我们来逐行解析它的工作流程：

1.  **`if (!p_imu->after_imu_init_)`** 逻辑判断,略.
2.  **`if (!p_imu->imu_need_init_)`** 逻辑判断,略.
3.  **`if (imu_en)` 分支**

      * `imu_en` 是一个布尔值，用于判断是否启用IMU。
      * **当IMU启用时**：
          * `tmp_gravity = -p_imu->mean_acc / p_imu->mean_acc.norm() * G_m_s2;`
          * 这是最关键的一步。它使用IMU静止时测得的平均加速度 `mean_acc` 来计算初始重力向量。
          * `p_imu->mean_acc.norm()`: 对加速度向量取模，得到其大小。
          * `p_imu->mean_acc / ...`: 将加速度向量归一化，得到一个纯方向向量。
          * `* G_m_s2`: 乘以重力常数（如9.81），使其大小与标准重力匹配。
          * **最重要的是前面的负号 `-`**：因为静止的加速度计测量的不是重力本身，而是支撑力（专业上称为“比力”或“真加速度”）。这个支撑力的方向是竖直向上的，与重力方向正好相反。因此，需要加一个负号才能得到重力向量的方向。
      * **当IMU被禁用时** (`else` 分支):
          * `tmp_gravity << VEC_FROM_ARRAY(gravity_init);`
          * 如果系统中没有IMU，就无法通过测量来获取重力方向。此时，代码会直接使用参数文件中预设的 `gravity_init` 值作为初始的重力向量。这提供了一种无IMU情况下的备用初始化方案，此时系统假定LiDAR初始时刻的坐标系与 `gravity_init` 所描述的重力方向是对齐的。

4.  **调用 `Set_init`**

      * `p_imu->Set_init(tmp_gravity, rot_init);`
      * 将上一步中得到的、代表当前IMU感受到的重力向量 `tmp_gravity`，传递给前面分析过的 `Set_init` 函数。
      * 该函数执行核心的轴-角计算，并将结果（一个3x3的旋转矩阵）存入 `rot_init`。

5.  **应用初始化旋转**

      * `kf_input.x_.rot = rot_init;`
      * `kf_output.x_.rot = rot_init;`
      * `rot_init` 现在代表了从初始IMU坐标系到世界坐标系（重力方向为Z轴负方向）的旋转。代码将这个旋转矩阵作为初始姿态，赋值给卡尔曼滤波器（Kalman Filter）的状态变量 `x_.rot`。这是整个对准过程的最终目的——为滤波器提供一个准确的初始姿态。

6.  **初始化加速度状态**

      * `kf_output.x_.acc = -rot_init.transpose() * kf_output.x_.gravity;`
      * 这一行同样是为了保持滤波器状态的一致性。`kf_output.x_.gravity` 通常是世界系下的标准重力向量（如 `[0, 0, -9.81]`）。`rot_init.transpose()` 是从世界系到IMU系的旋转。因此，这行代码计算出在初始姿态下，IMU坐标系中应该感受到的加速度值，并用它来初始化滤波器的加速度状态变量 `x_.acc`。

#### 那么,最后发生了什么?

在程序正确运行的情况下,你可以打开rviz2,发现即便你的雷达放置的方式是倾斜的,但是代表初始位姿的`camera_init`坐标系已经和地面垂直(这一点可以从`/cloud_registered`看出来,点云中的地面应该和`camera_init`的z轴垂直或者近似垂直),同时`body`坐标系仍然是斜着的,良好的反映了当前里程计的运行情况。

相信你不难想到,这会带来怎样的好处😁.