# 6. 从IKFoM开始的0基础SLAM代码阅读

## 阅读基础

### 什么是KF?什么是IESKF?

**卡尔曼滤波器（Kalman Filter, KF）**

卡尔ман滤波器是一种高效的递归滤波器（自回归滤波器），它能够在存在不确定性的情况下，对动态系统的状态进行最优估计。即便我们无法精确知道所关心系统的具体状态，卡尔曼滤波器也能够通过一系列包含噪声的测量数据，对系统状态进行猜测，并不断地用新的测量数据来修正和更新这个猜测，使其尽可能地接近真实值。

可以把卡尔曼滤波器的过程理解为一个“预测-更新”的循环：

1.  **预测 (Predict)**：根据系统前一时刻的状态，建立一个物理模型（状态转移模型），来预测当前时刻系统应该处于什么状态。这个预测结果会有一个与之相关联的不确定性（用协方差矩阵表示）。
2.  **更新 (Update)**：利用传感器获取到的当前时刻的测量值，来修正预测阶段得到的状态。因为测量值本身也包含噪声（测量噪声），所以更新过程实际上是在“预测值”和“测量值”之间取一个加权平均。权重的大小取决于预测的不确定性和测量的不确定性。如果预测的不确定性大，那么我们更相信测量值；反之，如果测量值噪声很大，我们就更相信预测值。

**核心思想：** 将来自模型预测的不确定信息和来自传感器测量的不确定信息进行数据融合，得到一个比单独使用任何一个都更精确的估计。

**数学表示:**

一个线性的动态系统可以用以下两个方程来描述：

* **状态方程**：描述了系统状态如何随时间演化
    ```math
    x_k = A x_{k-1} + B u_{k-1} + w_{k-1}
    ```
    其中：
    * $x_k$ 是系统在时刻 $k$ 的状态向量。
    * $u_{k-1}$ 是在时刻 $k-1$ 的控制输入。
    * $A$ 是状态转移矩阵，它将前一时刻的状态 $x_{k-1}$ 映射到当前时刻。
    * $B$ 是控制输入矩阵，它将控制输入 $u_{k-1}$ 的作用映射到当前状态。
    * $w_{k-1}$ 是过程噪声，假设它服从均值为0，协方差为 $Q$ 的高斯分布，即 $w_{k-1} \sim N(0, Q)$。

* **观测方程**：描述了如何通过测量值来观测系统状态
    ```math
    z_k = H x_k + v_k
    ```
    其中：
    * $z_k$ 是在时刻 $k$ 的测量向量。
    * $H$ 是观测矩阵，它将状态向量 $x_k$ 映射到测量空间。
    * $v_k$ 是测量噪声，假设它服从均值为0，协方差为 $R$ 的高斯分布，即 $v_k \sim N(0, R)$。

卡尔曼滤波器正是基于这两个方程进行“预测-更新”循环，来估计 $x_k$ 的值。

---

**迭代扩展卡尔曼滤波器 (Iterated Extended Kalman Filter, IESKF)**

标准的卡尔曼滤波器要求系统是线性的。然而，在SLAM或者机器人领域，系统模型（例如机器人的运动模型）和观测模型通常是非线性的。

* **扩展卡尔曼滤波器 (Extended Kalman Filter, EKF)** 是对标准KF的扩展，用于处理非线性系统。它的核心思想是：在某个估计点附近，通过泰勒展开对非线性函数进行一阶线性化（即用雅可比矩阵来近似），然后就可以在这个局部线性化的模型上应用标准的卡尔曼滤波流程。EKF的缺点在于，线性化会引入误差，尤其是在系统非线性程度很强的情况下，这种误差会很显著。

* **迭代扩展卡尔曼滤波器 (IESKF)** 是对EKF的一种改进。EKF只在上一时刻的估计值处进行一次线性化，然后就计算出当前时刻的估计结果。而IESKF认为，这一次线性化可能不够准，尤其当新的测量数据和预测值差异很大时。

    因此，IESKF在**更新**步骤中引入了一个迭代优化的过程。它会这么做：
    1.  和EKF一样，先在线性化点（通常是预测值）计算一个更新后的状态。
    2.  然后，IESKF会检查这个新的状态估计值是否比原来的线性化点更好。如果更好，它就会把这个**新的状态估计值**作为**新的线性化点**。
    3.  重复步骤1和2，即：**重新计算雅可比矩阵，重新计算卡尔曼增益，重新计算更新后的状态**。
    4.  这个迭代过程会持续好几次（或者直到状态更新量的变化足够小），从而找到一个更优的线性化点，使得最终的状态估计更加精确。

**总结一下KF家族：**

* **KF**: 用于线性系统。
* **EKF**: 用于非线性系统，通过在**一个**工作点进行一阶线性化来近似。
* **IESKF**: EKF的改进版，在**更新**步骤中，通过**多次迭代**来寻找一个更好的线性化工作点，从而获得更精确的状态估计。这在处理高非线性问题时尤其有效，常见于高精度的惯性导航和SLAM融合算法中。

### 什么是李群?什么是流形?

**流形 (Manifold)**

在简单的欧几里得空间（比如我们熟悉的2D平面或3D空间）中，我们可以用一个全局的坐标系来描述任何一个点，并且两点之间可以很自然地做加减法。然而，很多空间并没有这么好的性质。

**流形**是一个数学概念，用来描述那些“局部看起来像欧几里得空间”的空间。一个典型的例子就是地球表面。

* **局部像欧氏空间**：如果你只看你脚下的一小块地方（比如一个足球场），它基本上是平的，你可以用二维坐标 (x, y) 来描述位置。这块局部区域就和欧几里得平面（$R^2$）很像。
* **全局不是欧氏空间**：但从全局来看，地球是一个球面，它不是一个平面。你没法用一个单一的、全局的二维坐标系来无畸变地描述地球上的所有点（这就是为什么世界地图总是会有形变）。并且，在球面上做向量加法，规则也和平面上完全不同。

在SLAM和机器人学中，我们经常遇到的**旋转**就是一个典型的流形。一个三维旋转可以用一个3x3的旋转矩阵来表示。所有这些旋转矩阵构成的集合，它就不是一个欧几里得空间，而是一个流形，我们称之为 $SO(3)$。你不能把两个旋转矩阵直接相加，得到的矩阵就不再是一个旋转矩阵了（不再满足 $R^T R = I, \det(R)=1$ 的性质）。但是，在某个旋转附近做一个微小的扰动（一个微小的旋转），这个扰动可以用一个三维向量来描述，这个微小的局部空间就像 $R^3$ 一样。

---

**李群 (Lie Group)**

李群是一种特殊的流形，它额外增加了一个**群结构**。

* **群 (Group)**：在数学中，“群”指的是一个集合以及定义在该集合上的一个二元运算，这个组合需要满足四个基本性质：
    1.  **封闭性**: 集合中任意两个元素运算后的结果仍然在该集合中。（例如，两个旋转矩阵相乘，结果还是一个旋转矩阵）。
    2.  **结合律**: $(a \cdot b) \cdot c = a \cdot (b \cdot c)$。
    3.  **存在单位元**: 集合中存在一个特殊元素 $e$，对于任何元素 $a$，都有 $a \cdot e = e \cdot a = a$。（对于旋转矩阵，单位元就是单位矩阵 $I$）。
    4.  **存在逆元**: 对于集合中任何元素 $a$，都存在一个逆元 $a^{-1}$，使得 $a \cdot a^{-1} = a^{-1} \cdot a = e$。（对于旋转矩阵，其逆元就是它的转置 $R^{-1} = R^T$）。

* **李群 (Lie Group)**：一个李群既是一个流形，也是一个群。并且，它的群运算（乘法和求逆）是光滑（连续可微）的。

简单来说，**李群 = 光滑的流形 + 群结构**。

在SLAM中，最重要的李群就是和机器人位姿相关的群：

* **$SO(3)$ (Special Orthogonal Group)**: 三维旋转群。它包含了所有三维空间中的旋转矩阵。它是一个流形，因为旋转是连续变化的；它也是一个群，因为旋转可以复合（矩阵相乘）和求逆（反向旋转）。
* **$SE(3)$ (Special Euclidean Group)**: 三维刚体变换群。它包含了旋转和平移。一个 $SE(3)$ 中的元素通常用一个4x4的齐次变换矩阵表示，它既能描述物体的姿态（旋转），也能描述物体的位置（平移）。这正是描述相机或机器人在三维空间中位姿的数学工具。

**为什么李群在SLAM中如此重要？**

因为机器人的位姿（旋转+平移）本身就构成一个李群（$SE(3)$）。当我们想在优化问题（比如图优化SLAM）中对位姿进行求导和更新时，我们不能像在欧氏空间里那样直接做加减法。我们需要借助李群理论，引入**李代数 (Lie Algebra)** 的概念。

李代数是与李群相关联的一个向量空间，可以看作是李群在单位元附近的**局部线性化近似**。我们可以把李群中的优化变量（例如一个旋转矩阵）映射到其对应的李代数（一个三维向量）上，在李代数这个“平坦”的向量空间里进行求导和优化计算（做加法），然后再把结果映射回李群空间。这个过程完美地解决了在流形上进行优化的难题。

## IKFoM

说了这么多,我们来了解一下IKFoM.

打开`FAST-LIO`/`Faster-LIO`/`Point-LIO`的`include`目录,我们可以看到一个共同的子目录叫`IKFoM_toolkit`.IKFoM,即**Iterated Kalman Filters on Manifolds**（流形上的迭代卡尔曼滤波）。

从名字上我们就可以把它拆解为两部分来理解：**on Manifolds** 和 **Iterated Kalman Filters**。这恰好对应了我们前面讨论过的两个概念。

这个工具箱的本质，就是提供了一套在**流形**上进行**迭代扩展卡尔曼滤波 (IESKF)** 的通用框架。我们知道，在SLAM问题中，机器人的位姿（尤其包含了旋转部分）本身是定义在一个流形（李群 $SE(3)$）上的，而不是一个简单的欧几里得向量空间。

如果我们直接对位姿状态（比如用欧拉角表示旋转）应用标准的EKF或IESKF，会遇到很多问题，比如万向锁（Gimbal Lock）、奇异性以及角度的非线性叠加问题。这会导致滤波器性能下降甚至发散。

IKFoM的核心思想就是**将状态估计和误差分析分离**：

1.  **状态在流形上 (State on Manifold)**：系统的“名义状态” (Nominal State) $\hat{x}$ 始终在流形 $\mathcal{M}$ 上进行传播和更新。例如，一个旋转矩阵，我们始终保证它是一个合法的旋转矩阵。

2.  **误差在切空间上 (Error in Tangent Space)**：我们不再直接估计状态 $x$ 本身，而是估计一个微小的“误差状态” (Error State) $\delta x$。这个误差状态被定义在名义状态 $\hat{x}$ 所在位置的**切空间** $T_{\hat{x}}\mathcal{M}$ 上。切空间是一个欧几里得向量空间（可以简单理解为流形在某一点的局部线性化平面），因此，我们可以在这个空间里放心地使用标准的卡尔曼滤波理论，因为这里的加减法是有良好定义的。

**IKFoM的工作流程可以概括如下：**

1.  **预测 (Prediction)**：
    根据系统的运动学模型，在**流形**上对名-义状态进行预测。例如，对于位姿，就是将上一时刻的位姿 $\hat{\mathbf{T}}_{k-1}$ 乘以一个位姿增量 $\Delta \mathbf{T}$，得到当前时刻的预测位姿 $\check{\mathbf{T}}_k$。
    ```math
    \check{\mathbf{T}}_k = \hat{\mathbf{T}}_{k-1} \cdot \Delta \mathbf{T}
    ```
    同时，误差状态的协方差矩阵 $\mathbf{P}$ 也会根据线性化的误差动态学模型进行传播。

2.  **更新 (Update)**：
    当一个新的测量 $z_k$ 到来时：
    a. 计算预测的测量值 $\check{z}_k = h(\check{x}_k)$ 和实际测量值之间的残差（Innovation）。
    b. **关键一步**：将这个非线性的测量函数 $h(x)$ 在当前的预测状态 $\check{x}_k$ 处进行线性化，得到观测雅可比矩阵 $\mathbf{H}$。这个雅可比矩阵建立了**切空间中的误差状态 $\delta x$** 和**测量残差**之间的线性关系。
    c. 在切空间（一个向量空间）中，使用标准的卡尔曼滤波公式计算卡尔曼增益 $\mathbf{K}$。
    d. 计算出最优的**误差状态估计值** $\delta \hat{x}$。
    ```math
    \delta \hat{x} = \mathbf{K} \cdot (z_k - \check{z}_k)
    ```
    e. **状态更新（Retraction）**: 将计算得到的误差向量 $\delta \hat{x}$ 从切空间 “收缩” (Retract) 或者说 “注入” (Inject) 回流形中，用来更新名义状态。这个操作通常通过李群的**指数映射 (Exponential Map)** 来完成。
    ```math
    \hat{x}_k = \check{x}_k \oplus \delta \hat{x} \quad (\text{例如, 对于李群来说就是 } \hat{\mathbf{T}}_k = \check{\mathbf{T}}_k \cdot \text{Exp}(\delta \hat{x}))
    ```
    这里的 $\oplus$ 符号代表在流形上的更新操作，而不是简单的向量加法。
    f. 更新误差状态的协方差矩阵 $\mathbf{P}$。

3.  **迭代 (Iteration)**：
    和IESKF一样，上述的“更新”步骤可以重复进行多次。在第一次更新后，我们得到了一个更好的名义状态估计 $\hat{x}_k$。我们可以把这个新的估计值作为新的线性化点，重新计算测量残差和雅可比矩阵，然后再次计算误差状态并更新名义状态。通过2-3次迭代，可以获得比传统EKF更精确的结果。

**总结来说，IKFoM为处理基于流形的状态（如SLAM中的位姿）提供了一个严谨且高效的滤波框架。它通过在流形的切空间中定义和处理误差状态，巧妙地避免了直接在非线性流形空间中进行操作的困难，使得强大的卡尔曼滤波理论可以被正确地应用，这也是为什么它成为许多现代高性能LIO系统的核心组件。**

## FAST-LIO

`FAST-LIO`系列算法是`IKFoM`框架的一个典型应用。我们通过分析其代码，可以更具体地理解IKFoM是如何工作的。

### 状态、输入与噪声的流形定义

首先，我们来看看 `use-ikfom.hpp` 文件中是如何通过宏 `MTK_BUILD_MANIFOLD` 来定义系统状态的。这清晰地展示了哪些变量被放在了流形上进行估计。

```cpp
// 定义系统状态流形
MTK_BUILD_MANIFOLD(state_ikfom,
((vect3, pos))          // position in world frame (R^3)
((SO3, rot))            // rotation from body to world frame (SO(3))
((SO3, offset_R_L_I))   // extrinsic rotation from IMU to LiDAR (SO(3))
((vect3, offset_T_L_I)) // extrinsic translation from IMU to LiDAR (R^3)
((vect3, vel))          // velocity in world frame (R^3)
((vect3, bg))           // gyroscope bias (R^3)
((vect3, ba))           // accelerometer bias (R^3)
((S2, grav))            // gravity vector in world frame (S^2)
);

// 定义系统输入
MTK_BUILD_MANIFOLD(input_ikfom,
((vect3, acc))          // accelerometer measurement (R^3)
((vect3, gyro))         // gyroscope measurement (R^3)
);

// 定义过程噪声
MTK_BUILD_MANIFOLD(process_noise_ikfom,
((vect3, ng))           // gyroscope noise
((vect3, na))           // accelerometer noise
((vect3, nbg))          // gyroscope bias noise
((vect3, nba))          // accelerometer bias noise
);
```

**状态向量 `state_ikfom` 解析：**

这个结构体定义了卡尔曼滤波器需要估计的所有状态量。它是一个复合流形，由多个子流形构成：

  * `pos` (vect3): LiDAR在世界坐标系（通常是第一帧的LiDAR坐标系）下的**位置**。它属于 $R^3$ 空间。
  * `rot` (SO3): IMU本体坐标系到世界坐标系的**旋转**。这是一个李群 $SO(3)$，也是为什么要使用流形滤波的关键。
  * `offset_R_L_I` (SO3): 雷达坐标系到IMU坐标系的**外参旋转**。同样是一个 $SO(3)$ 成员。在线估计外参可以提高系统的精度和鲁棒性。
  * `offset_T_L_I` (vect3): 雷达坐标系到IMU坐标系的**外参平移**。属于 $R^3$ 空间。
  * `vel` (vect3): LiDAR在世界坐标系下的**速度**。属于 $R^3$ 空间。
  * `bg` (vect3): 陀螺仪的**偏置 (bias)**。它被建模为在 $R^3$ 空间中缓慢变化的随机游走。
  * `ba` (vect3): 加速度计的**偏置 (bias)**。同样属于 $R^3$ 空间。
  * `grav` (S2): 在世界坐标系下**重力向量**的表示。它被显式地估计，以更好地解算出加速度计的偏差和系统的姿态。重力向量的方向定义在一个二维球面流形 $S^2$上，因为它的模长是固定的。

**输入 `input_ikfom` 和 过程噪声 `process_noise_ikfom` 解析：**

  * `input_ikfom` 定义了IMU的测量值（加速度和角速度），它们将作为输入驱动卡尔曼滤波器的**预测**步骤。
  * `process_noise_ikfom` 定义了驱动IMU模型噪声的各个分量，包括IMU本身的测量噪声 (`ng`, `na`) 和偏置的随机游走噪声 (`nbg`, `nba`)。这些噪声的协方差矩阵就是我们在卡尔曼滤波器中常说的 $\mathbf{Q}$ 矩阵。

### 基本流程梳理

`FAST-LIO` 的主流程 `timer_callback` 中，处理激光雷达数据的核心逻辑可以分解为以下几步：

#### 1\. IMU初始化和预处理

在LiDAR数据到来之前，系统会接收并处理IMU数据。

核心代码: `p_imu->Process(Measures, kf, feats_undistort);`

`Process` 函数内部做了两件重要的事情：

  * **IMU前向传播 (Forward Propagation)**：使用两帧LiDAR数据之间的所有IMU测量值，通过运动学模型（考虑了我们刚刚定义的`state_ikfom`中的速度、偏置等）对状态进行**预测**。这一步只更新了状态的预测值和协方差，但没有用到LiDAR的测量。
  * **点云运动畸变校正**：由于一帧LiDAR扫描需要一定时间，而在这段时间内传感器在持续运动。该函数会利用IMU预测的高频位姿，为每个LiDAR点计算其精确的扫描时刻位姿，并将所有点校正到该帧扫描的结束时刻，从而消除运动畸变。输出的结果就是 `feats_undistort`。

#### 2\. 更新KF (Kalman Filter)

当经过预处理和降采样的点云准备好后，就进入了卡尔曼滤波器的**更新**阶段。这部分是整个算法的精髓，完美体现了IKFoM的应用。

如你所梳理的，整个更新过程不是简单地调用一个函数，而是通过一个**回调函数**机制实现的，这使得IKFoM框架可以与具体的测量模型（这里是点到平面的ICP模型）解耦。

1.  **`kf.init_dyn_share(...)` (初始化时)**:
    在系统启动时，将一个名为 `h_share_model` 的函数“注册”到卡尔曼滤波器 `kf` 实例中。`kf` 并不关心 `h_share_model` 内部做了什么，它只知道在需要更新时，可以调用这个函数来获取**测量雅可比矩阵 H** 和 **测量残差 h**。

2.  **`kf.update_iterated_dyn_share_modified(...)` (运行时)**:
    在主循环中，调用此函数来启动迭代更新过程。此函数内部会：
    a. 进入一个迭代循环（例如，最多迭代 `NUM_MAX_ITERATIONS` 次）。

    b. 在每次迭代中，调用之前注册的 `h_share_model` 函数。

    c. `h_share_model` 函数利用**当前迭代的KF状态估计** `s` (即`state_ikfom`的实例)，将当前帧的点云变换到世界坐标系下，并在地图中寻找匹配的平面，然后计算出每个点的**点到平面距离（残差）以及这个距离关于状态变量的导数（雅可比矩阵H的一行）**。

    d. `h_share_model` 将计算好的 `H` 和 `h` 填充到 `ekfom_data` 中并返回。

    e. `update_iterated_dyn_share_modified` 函数拿到 `H` 和 `h` 后，执行一次标准的卡尔曼滤波更新计算，得到一个在**切空间**上的误差状态修正量 $\delta \hat{x}$。

    f. 使用流形上的更新操作 (Retraction)，将这个修正量作用到主状态上：$\hat{x}_{new} = \hat{x}_{old} \oplus \delta \hat{x}$。

    g. 用更新后的状态 $\hat{x}_{new}$ 进入下一次迭代，重复 b-f 步骤。

    h. 迭代几次或收敛后，将最终的更新结果应用到KF的状态和协方差上。

通过代码可以看到，`h_share_model` 函数的核心就是实现了从**状态**到**测量残差**的映射关系 $h(x)$，并计算了其雅可比 $\mathbf{H} = \frac{\partial h}{\partial \delta x}$。这正是任何基于卡尔曼滤波的SLAM算法都需要实现的核心测量模型部分。